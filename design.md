## Участники группы

* Носивской Владислав
* Саврасов Михаил
* Левин Лев
* Широков Кирилл

## Структурная диаграмма

![Диаграмма](diagram.svg)

## Правила для лексера и парсера

В этой части будут расписаны формальные правила для лексера и парсера,
которые программист перенесет в код (как именно -- будет расписано
позднее)

Синтаксис отсылается к использованию библиотеки `yecc` (`yacc` для Erlang)

Есть отдельный парсер для команд и для аргументов. Это сделано, чтобы
передавать в парсер аргументов вывод команд при перебрасывании вывода в пайпе.


* Лексер

```
Definitions.

CHAR_SEQUENCE  = [^\s\'"]+
WEAK_QUOTING   = '[^']*'
STRONG_QUOTING = "[^"]*"
WORD           = ({CHAR_SEQUENCE}|{WEAK_QUOTING}|{STRONG_QUOTING})+
VAR_NAME       = [_a-zA-Z\-]+[\w\-]*
WHITESPACE     = \s

Rules.

|                                             : pipe.
^{WHITESPACE}*{VAR_NAME}={WORD}{WHITESPACE}*$ : assignment.
{WORD}                                        : word.
{WHITESPACE}+                                 : skip_token.
```

* Парсер команд (Оставляет аргументы как есть)

```
Terminals pipe, word, assignment.
Nonterminals args, atom, command, function.
Rootsymbol command.

Left pipe. (Левоасс. оператор)

command -> command pipe command.
command -> assignment.
command -> atom.

atom -> function.
atom -> function args.

args -> arg.
args -> arg args.

arg -> word.

function -> word.
```

## Архитектурные сущности

### CLI

Основной компонент для взаимодействия с консолью

Методы:

* Чтение строки из консоли
* Вывести строку в консоль

### Lexer

Лексер для токенизации строки. Возвращает список токенов или бросает исключение, если строку не удалось разобрать полностью.

Правила для лексера описаны выше, от программиста требуется перевести 
правила в код, согласно формату библиотеки [PLY](https://github.com/dabeaz/ply).

### CommandParser

Парсер для первичной обработки команды. Принимает список токенов, возвращает
AST, построенное с помощью библиотеки [PLY](https://github.com/dabeaz/ply)
по грамматике, приведенной выше. Удаляет знаки кавычек, ограничивающие все внешние строки (т.е. остаются только те, которые не находятся в какой-то внешней строке).

На выходе AST является полностью разобранной командой.

### EnvironmentHandler

Компонент, отвечающий за работу с переменными среды. Хранит внутренние
переменные, которые ввел пользователь.

По имени переменной выдает значение или записывает новое. При своем создании сохраняет значения переменной среды.

### Substitute

Производит подстановки переменных в строке.

Ищет очередной оператор `$` в строке и жадно набирает имя переменной (regex `[_a-zA-Z\-]+[\w\-]*`). После чего производит подстановку с помощью `EnvironmentHandler`.
Поддерживает strong и weak quoting.

### FunctionsHandler

Компонент, хранящий наши реализации команд и обращающийся к системе для 
нереализованных команд.

В случае, если не нашлась наша реализация, возвращает лямбду, которая при вызове обращается к системной реализации команды.

### FunctionsExecutor

Компонент, исполняющий команду с ее аргументами.
Внутри себя обращается к `FunctionHandler`, получает вызываемый объект.

Метод исполнения должен возвращать кортеж из кода исполнения, потока выходных данных, потока ошибок.
Корректно завершенный вызов имеет код 0, некорректно завершенный вызов внешней функции имеет
код, который передала система; некорректно завершенный вызов внутренней функции имеет код не равный нулю
на усмотрение разработчика.

### ASTWalker

Компонент, содержащий основную логику исполнения команды.

Принимает AST, которое нужно обойти и выполнить. Каждая вершина дерева является кортежом из имени команды и ее аргументов. Если операция является пайпом или присваиванием, выполняет их. Иначе обращается в `FunctionsExecutor`, который хранит реализации остальных команд. 

### Main

Главный модуль.

При запуске создает объекты классов `CLI`, `Substitute`, `CommandParser` (`ASTWalker` имеет только статические методы). Поскольку каждый из соответствующих им модулей не должен знать о других, после создания этих обхектов инициализация не требуется, и программа готова считывать ввод пользователя.

Для получения ввода и вывода на экран, `Main` взаимодействует с `CLI`. Принятая от последнего строка передается в `Substitute`, который подставляет в помеченные `$` места значения переменных. После этого `Main` проводит строку, для которой подстановки значений переменных уже не требуются, через `CommandParser`. Полученное AST дальше отдается в `ASTWalker`, который выполняет распознанные команды, обходя это дерево.

После выполнения команды `Main` получает от `ASTWalker` код возврата, поток ошибок и вывода. Если последние два не пустые, то с помощью `CLI` их содержимое выводится на экран. Далее ожидается новый ввод пользователя.

Программа может завершиться командой `exit` или комбинациями Ctrl+C, Ctrl+D. Первая закрывает приложение, когда ее выполняет `ASTWalker`, остальные отлавливает `Main`.

## Реализованные команды

### echo

Выводит в свои аргументы через пробел, переводя строку в конце. Игнорирует поток ввода.

### cat

Выводит содержимое файлов, имена которых были переданы через аргументы. Если аргументы отсутствуют, выводит содержимое потока ввода.

### wc

Выводит количество переводов строк, слов и байт, а также имена файлов, полученных через аргументы. Если аргументы отсутствуют, выводит ту же статистику для потока ввода.

### pwd

Выводит путь до текущей директории с переводом строки.

### exit

Выходит из CLI.

### PIPE

Левоассоциативная операция, передающая поток вывода левой команды как поток ввода правой и выполняет их. В частности, из этого следует, что если одна из переданных пайпу команд будет `exit`, при ее выполнении CLI завершится.

## Потоки

А их нет.

Код однопоточный, при этом если параллельно в другом процессе будут изменяться переменные среды всего баша, запущенный CLI не увидит эти изменения.
